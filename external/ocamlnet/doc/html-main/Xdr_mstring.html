<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Rtypes.html">
<link rel="next" href="Xdr.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html"><link title="How to practically use managed strings" rel="Section" href="#2_Howtopracticallyusemanagedstrings">
<link title="Interface" rel="Section" href="#2_Interface">
<title>Ocamlnet 3 Reference Manual : Xdr_mstring</title>
</head>
<body>
<div class="navbar"><a href="Rtypes.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Xdr.html">Next</a>
</div>
<center><h1>Module <a href="type_Xdr_mstring.html">Xdr_mstring</a></h1></center>
<br>
<pre><span class="keyword">module</span> Xdr_mstring: <code class="code">sig</code> <a href="Xdr_mstring.html">..</a> <code class="code">end</code></pre>Managed Strings<br>
<hr width="100%">
<br>
Managed strings are used in XDR context for constant strings that
    are stored either as string or as memory (bigarray of char).
<p>

    A managed string <code class="code">ms</code> is declared in the XDR file as in
<p>

    <pre><code class="code">      typedef _managed string ms&lt;&gt;;
    </code></pre>
<p>

    In the encoded XDR stream there is no difference between strings and
    managed strings, i.e. the wire representation is identical. Only
    the Ocaml type differs to which the managed string is mapped. This
    type is <a href="Xdr_mstring.mstring.html"><code class="code">Xdr_mstring.mstring</code></a> (below).
<p>

    In the RPC context there is often the problem that the I/O backend
    would profit from a different string representation than the user of
    the RPC layer. To bridge this gap, managed strings have been invented.
    Generally, the user can determine how to represent strings (usually
    either as an Ocaml string, or as memory), and the I/O backend
    can request to transform to a different representation when this
    leads to an improvement (i.e. copy operations can be saved).
<p>

    Only large managed strings result in a speedup of the program
    (at least several K).
<p>

    <a name="2_Howtopracticallyusemanagedstrings"></a>
<h2>How to practically use managed strings</h2>
<p>

    There are two cases: The encoding case, and the decoding case.
    In the encoding case the <code class="code">mstring</code> object is created by the user
    and passed to the RPC library. This happens when a client prepares
    an argument for calling a remote procedure, or when the server
    sends a response back to the caller. In the decoding case the client
    analyzes the response from an RPC call, or the server looks at the
    arguments of an RPC invocation. The difference here is that in the
    encoding case user code can directly create <code class="code">mstring</code> objects by
    calling functions of this module, whereas in the decoding case the
    RPC library creates the <code class="code">mstring</code> objects.
<p>

    For simplicity, let us only look at this problem from the perspective
    of an RPC client.
<p>

    <b>Encoding.</b> Image a client wants to call an RPC, and one of the
    arguments is a managed string. This means we finally need an <code class="code">mstring</code>
    object that can be put into the argument list of the call.
<p>

    This library supports two string representation specially: The normal
    Ocaml <code class="code">string</code> type, and <a href="Netsys_mem.html#TYPEmemory"><code class="code">Netsys_mem.memory</code></a> which is actually just
    a bigarray of char's. There are two factories <code class="code">fac</code>,
<p>
<ul>
<li><a href="Xdr_mstring.html#VALstring_based_mstrings"><code class="code">Xdr_mstring.string_based_mstrings</code></a>, and</li>
<li><a href="Xdr_mstring.html#VALmemory_based_mstrings"><code class="code">Xdr_mstring.memory_based_mstrings</code></a>,</li>
</ul>

    and both can be used to create the <code class="code">mstring</code> to pass to the
    RPC layer. It should be noted that this layer can process the
    <code class="code">memory</code> representation a bit better. So, if the original <code class="code">data</code>
    value is a string, the factory for <code class="code">string</code> should be used, and
    if it is a char bigarray, the factory for <code class="code">memory</code> should be used.
    Now, the <code class="code">mstring</code> object is created by
<p>
<ul>
<li><code class="code">let mstring = fac # create_from_string data pos len copy_flag</code>, or by</li>
<li><code class="code">let mstring = fac # create_from_memory data pos len copy_flag</code>.</li>
</ul>

    Of course, if <code class="code">fac</code> is the factory for strings, the <code class="code">create_from_string</code>
    method works better, and if <code class="code">fac</code> is for <code class="code">memory</code>, the <code class="code">create_from_memory</code>
    method works better. <code class="code">pos</code> and <code class="code">len</code> can select a substring of <code class="code">data</code>.
    If <code class="code">copy_flag</code> is <code class="code">false</code>, the <code class="code">mstring</code> object does not copy the data
    if possible, but just keeps a reference to <code class="code">data</code> until it is accessed;
    otherwise if <code class="code">copy_flag</code> is <code class="code">true</code>, a copy is made immediately.
    Of couse, delaying the copy is better, but this requires that <code class="code">data</code>
    is not modified until the RPC call is completed.
<p>

    <b>Decoding.</b> Now, the call is done, and the client looks at the
    result. There is also an <code class="code">mstring</code> object in the result. As noted
    above, this <code class="code">mstring</code> object was already created by the RPC library
    (and currently this library prefers string-based objects if not
    told otherwise). The user code can now access this <code class="code">mstring</code>
    object with the access methods of the <code class="code">mstring</code> class (see below).
    As these methods are quite limited, it makes normally only sense
    to output the <code class="code">mstring</code> contents to a file descriptor.
<p>

    The user can request a different factory for managed strings. The 
    function <a href="Rpc_client.html#VALset_mstring_factories"><code class="code">Rpc_client.set_mstring_factories</code></a> can be used for this
    purpose. (Similar ways exist for managed clients, and for RPC servers.)
<p>

    <b>Potential.</b> Before introducing managed strings, a clean analysis
    was done how many copy operations can be avoided by using this
    technique. Example: The first N bytes of a file are taken as 
    argument of an RPC call. Instead of reading these bytes into a
    normal Ocaml string, an optimal implementation uses now a <code class="code">memory</code>
    buffer for this purpose. This gives:
<p>
<ul>
<li>Old implementation with strings and ocamlnet-2:
      Data is copied <b>six</b> times from reading it from the file until
      writing it to the socket.</li>
<li>New implementation with memory-based mstrings:
      Data is copied only <b>twice</b>! The first copy reads it from the
      file into the input buffer (a <code class="code">memory</code> value), and the second copy
      writes the data into the socket.</li>
</ul>

    Part of the optimization is that <code class="code">Unix.read</code> and <code class="code">Unix.write</code>
    do a completely avoidable copy of the data which is prevented by
    switching to <a href="Netsys_mem.html#VALmem_read"><code class="code">Netsys_mem.mem_read</code></a> and <a href="Netsys_mem.html#VALmem_write"><code class="code">Netsys_mem.mem_write</code></a>,
    respectively. The latter two functions exploit an optimization
    that is only possible when the data is <code class="code">memory</code>-typed.
<p>

    The possible optimizations for the decoding side of the problem
    are slightly less impressive, but still worth doing it.<br>
<br>
<a name="2_Interface"></a>
<h2>Interface</h2><br>
<pre><span class="keyword">class type</span> <a name="TYPEmstring"></a><a href="Xdr_mstring.mstring.html">mstring</a> = <code class="code">object</code> <a href="Xdr_mstring.mstring.html">..</a> <code class="code">end</code></pre><div class="info">
The object holding the string value
</div>
<pre><span class="keyword">class type</span> <a name="TYPEmstring_factory"></a><a href="Xdr_mstring.mstring_factory.html">mstring_factory</a> = <code class="code">object</code> <a href="Xdr_mstring.mstring_factory.html">..</a> <code class="code">end</code></pre><div class="info">
The object creating new <code class="code">mstring</code> objects
</div>
<pre><span class="keyword">val</span> <a name="VALstring_based_mstrings"></a>string_based_mstrings : <code class="type"><a href="Xdr_mstring.mstring_factory.html">mstring_factory</a></code></pre><div class="info">
Uses strings to represent mstrings<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmemory_based_mstrings"></a>memory_based_mstrings : <code class="type"><a href="Xdr_mstring.mstring_factory.html">mstring_factory</a></code></pre><div class="info">
Uses memory to represent mstrings. The memory bigarrays are allocated
      with <code class="code">Bigarray.Array1.create</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALpaligned_memory_based_mstrings"></a>paligned_memory_based_mstrings : <code class="type"><a href="Xdr_mstring.mstring_factory.html">mstring_factory</a></code></pre><div class="info">
Uses memory to represent mstrings. The memory bigarrays are allocated
      with <a href="Netsys_mem.html#VALalloc_memory_pages"><code class="code">Netsys_mem.alloc_memory_pages</code></a> if available, and 
      <code class="code">Bigarray.Array1.create</code> if not.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmemory_pool_based_mstrings"></a>memory_pool_based_mstrings : <code class="type"><a href="Netsys_mem.html#TYPEmemory_pool">Netsys_mem.memory_pool</a> -> <a href="Xdr_mstring.mstring_factory.html">mstring_factory</a></code></pre><div class="info">
Uses memory to represent mstrings. The memory bigarrays are obtained
      from the pool. The length of these mstrings is limited by the 
      blocksize of the pool.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlength_mstrings"></a>length_mstrings : <code class="type"><a href="Xdr_mstring.mstring.html">mstring</a> list -> int</code></pre><div class="info">
returns the sum of the lengths of the mstrings<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat_mstrings"></a>concat_mstrings : <code class="type"><a href="Xdr_mstring.mstring.html">mstring</a> list -> string</code></pre><div class="info">
concatenates the mstrings and return them as single string. The returned
      string may be shared with one of the mstrings passed in.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprefix_mstrings"></a>prefix_mstrings : <code class="type"><a href="Xdr_mstring.mstring.html">mstring</a> list -> int -> string</code></pre><div class="info">
<code class="code">prefix_mstrings l n</code>: returns the first <code class="code">n</code> chars of the 
      concatenated mstrings <code class="code">l</code> as single string<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblit_mstrings_to_memory"></a>blit_mstrings_to_memory : <code class="type"><a href="Xdr_mstring.mstring.html">mstring</a> list -> <a href="Netsys_mem.html#TYPEmemory">Netsys_mem.memory</a> -> unit</code></pre><div class="info">
blits the mstrings one after the other to the memory, so that
      they appear there concatenated<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEnamed_mstring_factories"></a><code class="type"></code>named_mstring_factories = <code class="type">(string, <a href="Xdr_mstring.mstring_factory.html">mstring_factory</a>) Hashtbl.t</code> </pre>

</body></html>