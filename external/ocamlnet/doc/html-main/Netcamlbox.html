<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Equeue_intro.html">
<link rel="next" href="Netcgi_apache.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html"><link title="Integration into event-based programs" rel="Section" href="#events">
<title>Ocamlnet 3 Reference Manual : Netcamlbox</title>
</head>
<body>
<div class="navbar"><a href="Equeue_intro.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netcgi_apache.html">Next</a>
</div>
<center><h1>Module <a href="type_Netcamlbox.html">Netcamlbox</a></h1></center>
<br>
<pre><span class="keyword">module</span> Netcamlbox: <code class="code">sig</code> <a href="Netcamlbox.html">..</a> <code class="code">end</code></pre>Camlboxes are a fast IPC mechanism to send Ocaml values from one
   process to another. Source and destination processes must run on
   the same machine (no network). The Ocaml value is copied to a
   shared memory object where it can be directly accessed by the
   receiver without unmarshalling step. This means the sender writes
   the value into the shared memory in a format that can immediately
   interpreted by the receiver.
<p>

   A camlbox is owned by the single receiving process. Only this process
   (or a fork) can look for new messages and can read them. There can be
   any number of sending processes, i.e. we have a n:1 message passing
   scenario.
<p>

   The receiver process creates the camlbox, and is seen as the owner.
   The receiver is accountible for deleting the camlbox when it is no
   longer needed.
<p>

   The sender(s) can send messages to any existing camlbox. There is
   no notification whether the messages are actually read. The sender,
   however, blocks when the destination camlbox is full, and will only
   proceed when the receiver makes room for new messages. If there is
   space in the camlbox the sender does not need to synchronize with the
   receiver, i.e. it is possible to put a message into the box when
   the receiver is busy with something else (asynchronous send operation).
<p>

   Camlboxes have a fixed capacity of messages, and the message slots
   have a fixed maximum length. The messages can have any type with only
   a few restrictions (e.g. no functions and no custom blocks). There is
   no check whether the sender and the receiver assume the same type
   of the messages. This is left to the user. Breaking this assumption
   will lead to unpredictable effects, including program crashes.
   It is strongly advised to only communicate between processes that
   run the same executable.
<p>

   The user is also responsible for keeping only references to 
   existing messages. It is possible to get a value pointer 
   for a certain message via <code class="code">camlbox_get</code> and then to delete the message. 
   The user must no longer access the value - once the value is deleted
   it may be overwritten, and the program may crash. Another danger
   is that message values are modified so that pointers to heap
   values are put into the message. This may lead to delayed crashes
   when the heap value is moved to a different location or is even
   deleted by the garbage collector. There is nothing the camlbox
   implementation can do about that. If this is a problem, it is
   advised to use <code class="code">camlbox_get_copy</code> instead which is not dangerous
   in this respect.
<p>

   On the system level, camlboxes are stored in POSIX shared memory
   objects. These objects have kernel persistence and continue to
   live after the process creating the camlbox has terminated without
   unlinking the box.
<p>

   This module requires Ocaml 3.11 or newer. The system must support
   POSIX shared memory and POSIX semaphores. Camlboxes may be used
   in multi-threaded programs as long as the values <code class="code">camlbox</code> and
   <code class="code">camlbox_sender</code> are not used by several threads at the same time.
<p>

   <b>Examples.</b> There a few examples in the distribution tarball
   (examples/camlbox).
<p>

   <b>Multi-core:</b>
   Camlboxes can be used to gain speed-ups on multi-cores. See
   examples/camlbox/README in the distribution tarball for an example
   how to accomplish this.
<p>

   <b>Integration into event-based programs:</b> See the section
   below, <a href="Netcamlbox.html#events"><i>Integration into event-based programs</i></a>.<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEcamlbox_address"></a><code class="type"></code>camlbox_address = <code class="type">string</code> </pre>
<div class="info">
The address of a camlbox is a string that does not contain
        slashes. Addresses are system-global.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEcamlbox"></a><code class="type">'a</code> camlbox </pre>
<div class="info">
A <code class="code">camlbox</code> may receive messages of type <code class="code">'a</code><br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEcamlbox_sender"></a><code class="type">'a</code> camlbox_sender </pre>
<div class="info">
An endpoint that may send messages of type <code class="code">'a</code> to a camlbox<br>
</div>

<pre><span class="keyword">exception</span> <a name="EXCEPTIONEmpty"></a>Empty</pre>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONMessage_too_big"></a>Message_too_big</pre>
<pre><span class="keyword">val</span> <a name="VALcreate_camlbox"></a>create_camlbox : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> int -> int -> 'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a></code></pre><div class="info">
<code class="code">create_camlbox addr n size</code>: Creates a new camlbox for up to
      <code class="code">n</code> messages of <code class="code">size</code> bytes. The messages are numbered from
      0 to <code class="code">n-1</code>. The camlbox is only meaningful for the creating
      process, and must not be directly accessed by other processes.
      Other processes can only send using a <code class="code">camlbox_sender</code>.
<p>

      It is an error if the camlbox already exists.
<p>

      It is suggested that the result of <code class="code">create_camlbox</code> is immediately
      coerced to the right type <code class="code">t</code>, e.g.
      <pre><code class="code">        let box = (create_camlbox addr n size : t camlbox)
      </code></pre>
      as this ensures type safety for all following operations.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunlink_camlbox"></a>unlink_camlbox : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> unit</code></pre><div class="info">
Removes the global name of the camlbox. All functions requiring 
      a <code class="code">camlbox_address</code> as input will not find the box anymore. The
      box, however, continues to exist until the receiver and the senders
      are done with it.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALformat_camlbox"></a>format_camlbox : <code class="type">Unix.file_descr -> int -> int -> 'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a></code></pre><div class="info">
<code class="code">format_camlbox fd n size</code>: The file <code class="code">fd</code> is mapped into memory,
      and formatted as camlbox.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_fd"></a>camlbox_fd : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> Unix.file_descr</code></pre><div class="info">
Opens a new file descriptor to this address<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_capacity"></a>camlbox_capacity : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> int</code></pre><div class="info">
Returns the maximum number of messages <code class="code">n</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_bcapacity"></a>camlbox_bcapacity : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int</code></pre><div class="info">
same for an already opened box<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_scapacity"></a>camlbox_scapacity : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a> -> int</code></pre><div class="info">
same for a box already opened for sending<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_msg_size"></a>camlbox_msg_size : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> int</code></pre><div class="info">
Returns the max size of a message in bytes<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_bmsg_size"></a>camlbox_bmsg_size : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int</code></pre><div class="info">
same for an already opened box<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_smsg_size"></a>camlbox_smsg_size : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a> -> int</code></pre><div class="info">
same for a box already opened for sending<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_messages"></a>camlbox_messages : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> int</code></pre><div class="info">
Returns the number of messages at the moment<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_bmessages"></a>camlbox_bmessages : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int</code></pre><div class="info">
same for an already opened box<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_smessages"></a>camlbox_smessages : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a> -> int</code></pre><div class="info">
same for a box already opened for sending<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_get"></a>camlbox_get : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int -> 'a</code></pre><div class="info">
<code class="code">camlbox_get box k</code>: Returns message number <code class="code">k</code> from <code class="code">box</code>.
      The returned value lives in the camlbox, and using it is only
      safe as long as the camlbox exists and the message is not
      deleted.
<p>

      If there is no message at <code class="code">k</code> the exception <code class="code">Empty</code> will be
      raised.
<p>

      The result value must have the same type as the sent value.
      This is not checked, however. Violating this rule is likely
      to crash the program.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_get_copy"></a>camlbox_get_copy : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int -> 'a</code></pre><div class="info">
<code class="code">camlbox_get box k</code>: Returns a deep copy of message number <code class="code">k</code> from <code class="code">box</code>.
      This is safer than <code class="code">camlbox_get</code>, because the returned value remains
      valid when the message is deleted from the box.
<p>

      If there is no message at <code class="code">k</code> the exception <code class="code">Empty</code> will be
      raised.
<p>

      The result value must have the same type as the sent value.
      This is not checked, however. Violating this rule is likely
      to crash the program.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_delete"></a>camlbox_delete : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int -> unit</code></pre><div class="info">
<code class="code">camlbox_delete box k</code>: Deletes the message number <code class="code">k</code> from <code class="code">box</code>.
      Any value obtained via <code class="code">camlbox_get</code> for a message or a part
      of a message becomes invalid and must not be used anymore.
      There is no way to check this - violating this rule is likely
      to crash the program. (In doubt use <code class="code">camlbox_get_copy</code> instead
      which cannot interfer with <code class="code">camlbox_delete</code>.)
<p>

      If there is no message at <code class="code">k</code> the exception <code class="code">Empty</code> will be
      raised.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_wait"></a>camlbox_wait : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> int list</code></pre><div class="info">
Waits until new messages arrive, and return the message numbers.
      A new message is only reported once by <code class="code">camlbox_wait</code>. The
      order of the messages is not specified.
<p>

      Only one thread at a time must wait for new messages.
<p>

      It is allowed that this function returns the empty list.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_cancel_wait"></a>camlbox_cancel_wait : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox">camlbox</a> -> unit</code></pre><div class="info">
Cancels a <code class="code">camlbox_wait</code> operation called by a different thread<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_sender"></a>camlbox_sender : <code class="type"><a href="Netcamlbox.html#TYPEcamlbox_address">camlbox_address</a> -> 'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a></code></pre><div class="info">
Prepares for sending.
<p>

      It is suggested that the result of <code class="code">camlbox_sender</code> is immediately
      coerced to the right type <code class="code">t</code>, e.g.
      <pre><code class="code">        let box = (camlbox_sender addr : t camlbox_sender)
      </code></pre>
      as this ensures type safety for all following operations.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_sender_of_fd"></a>camlbox_sender_of_fd : <code class="type">Unix.file_descr -> 'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a></code></pre><div class="info">
Gets a sender for a file descriptor from <code class="code">camlbox_fd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_send"></a>camlbox_send : <code class="type">?prefer:int -><br>       ?slot:int Pervasives.ref -> 'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a> -> 'a -> unit</code></pre><div class="info">
Sends a message to a camlbox. The value must be boxed (neither <code class="code">char</code>,
      <code class="code">bool</code>, <code class="code">int</code>, nor a variant type), and a number of restrictions apply:<ul>
<li>The size of the representation must not exceed the maximum
         message size of the camlbox, or the exception <code class="code">Message_too_big</code>
         is raised.</li>
<li>Objects, closures, and lazy values are not supported</li>
<li>Abstract and custom block values are not supported except
         bigarrays, <code class="code">int32</code>, <code class="code">int64</code>, and <code class="code">nativeint</code>.</li>
<li>Atoms (like empty arrays) may cause problems when the message
         is extracted by <code class="code">camlbox_get</code> because atoms are duplicated,
         and no longer unique. For example, a test <code class="code">if array=[||] then...</code>
         is likely not to work. Use <code class="code">if Array.length array = 0 then...</code>,
         or use <code class="code">camlbox_get_copy</code> for extraction.</li>
</ul>

      The value is copied to the receiving camlbox.
<p>

      This function blocks until the receiving camlbox has free space.
<p>

      Several threads may try to send messages at the same time.
<p>

      <code class="code">prefer</code>: suggests a slot for sending
      <code class="code">slot</code>: the actual slot number is stored here<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcamlbox_wake"></a>camlbox_wake : <code class="type">'a <a href="Netcamlbox.html#TYPEcamlbox_sender">camlbox_sender</a> -> unit</code></pre><div class="info">
Sends an "empty message" - this only means that if the receiving
      thread is waiting for new messages it is interrupted and 
      <code class="code">camlbox_wait</code> will return the empty list.
<p>

      This function is non-blocking.<br>
</div>
<br>
<a name="events"></a>
<h2>Integration into event-based programs</h2>
<p>

   The functions <code class="code">camlbox_wait</code> and <code class="code">camlbox_send</code> may both block the
   execution of the program when no message has arrived, and no space
   is available, respectively. This is a challenge for event-based
   programs where all waiting is bound to events on file descriptors.
<p>

   Generally, Camlboxes use semaphores for speed. The results are good,
   often only 4 microseconds for sending and receiving a short
   message.  This is only possible because semaphores implement a fast
   path where the help of the kernel is not needed, i.e. no context
   switch happens. This is basically incompatible with the style of
   waiting implemented for file descriptors, because this kind of
   waiting for an event must always go through the kernel, and is
   thus slower by design.
<p>

   But anyway, what to do if Camlboxes need to be integrated into
   a program that bases already on file descriptor polling? Of course,
   speed will decrease, but maybe not dramatically. We assume here
   that the program uses <a href="Unixqueue.html"><code class="code">Unixqueue</code></a>s as the basic data structure
   for organizing polling.
<p>

   <b>Option 1: Use Threads.</b> A program waiting for incoming Camlbox
   messages could be structured as follows:<ul>
<li>There is a fast path and a slow path. The fast path: After
      processing the previous message, the program looks at 
      the number of messages in the box, and if this is &gt; 0, the next
      message is immediately taken and processed (no waiting).</li>
<li>The slow path: If the number is zero, a worker thread is created
      that calls <code class="code">camlbox_wait</code> and thus blocks until a message arrives.
      If this happens, an artifical <code class="code">Unixqueue</code> event is created and
      added to <code class="code">esys</code>. While the spawned thread is waiting for the message,
      the main thread just performs its normal operations on the <code class="code">esys</code>
      (e.g. an RPC server processes incoming calls). The main thread is
      set up to watch for the special event the worker thread adds, and
      to run the piece of code processing the incoming message.</li>
</ul>

   As usual, multi-threaded programming is not very nice to control.
<p>

   <b>Option 2: Use a named pipe.</b> A program waiting for incoming Camlbox
   messages could be structured as follows. In this suggestion, we need
   help from the message sender to get notified in a poll-compatible
   way when a message is sent.<ul>
<li>The message receiver also creates a named pipe. The receiver opens
      one end of the pipe for reading. Every sender opens the other end
      of the pipe for writing.</li>
<li>When a message is sent, the sender not only sends the message via
      the camlbox, but also sends a single byte over the named pipe.</li>
<li>The receiver waits for events on the named pipe. If bytes arrive,
      they are read, and the fast path loop is entered.</li>
<li>In the fast path loop, the program looks repeatedly at 
      the number of messages in the box, and while this is &gt; 0, the next
      message is immediately taken and processed (no waiting).</li>
<li>When the fast path loop is left, control is passed back to the
      normal file descriptor polling.</li>
</ul>

   Instead of a named pipe, any other notification means can also be used,
   so far it is compatible with file descriptor polling. (E.g.
   Linux added recently the <code class="code">eventfd</code> system call as a cheaper
   way for pure notification via file descriptors.)
<p>

   The two options only handle the case of <code class="code">camlbox_wait</code>. But also
   <code class="code">camlbox_send</code> can block. This is usually a bit simpler to solve,
   especially in the case where two processes exchange messages, and
   both are sender and receiver. In this frequent scenario, one can
   track the number of messages in the Camlbox, and one can arrange that
   the sender is notified when the number of messages decreases, i.e.
   more space becomes available in the Camlbox. (In some sense, the
   problem of handling <code class="code">camlbox_send</code> is reduced to <code class="code">camlbox_wait</code>.)
<p>

   In the general case, though, when there are n&gt;1 senders, the
   problems of handling <code class="code">camlbox_send</code> is really difficult. One would
   need a way to broadcast events from the receiver to all senders.
   The only way I'm aware of (avoiding multi-threading) is the following:
<p>
<ul>
<li>Again, a (single) named pipe is used for notification. The
     receiver creates it, and opens both ends of the pipe. It writes
     bytes into the writing end until the internal pipe buffer is full.
     The write side is then closed, and only the read side is kept open.
     One byte is read, so initially the pipe buffer is almost full.
     We are going to use a full pipe buffer as representation that
     the Camlbox has no space, and an almost full pipe buffer (one free byte) as
     representation that the box has space.</li>
<li>The senders open the write end of the pipe. They poll until there
     is space in the pipe buffer. If so, they all try to write a single
     byte into the buffer, but in non-blocking mode. Usually only one
     sender will succeed doing so, and this sender is allowed to send
     the message via the Camlbox.</li>
<li>The receiver takes care that the notification via the pipe buffer
     works. After a message is processed, a byte is read from the 
     pipe buffer, allowing another message to be sent.</li>
</ul>

   One can improve this by encoding the number of free slots in the
   Camlbox via the number of free bytes in the pipe buffer (i.e. n
   free slots = n missing bytes in the buffer until it is full).<br>
</body></html>