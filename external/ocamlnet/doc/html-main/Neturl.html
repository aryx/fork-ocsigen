<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netsendmail.html">
<link rel="next" href="Netaddress.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html"><link title="Interface" rel="Section" href="#interface">
<title>Ocamlnet 3 Reference Manual : Neturl</title>
</head>
<body>
<div class="navbar"><a href="Netsendmail.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netaddress.html">Next</a>
</div>
<center><h1>Module <a href="type_Neturl.html">Neturl</a></h1></center>
<br>
<pre><span class="keyword">module</span> Neturl: <code class="code">sig</code> <a href="Neturl.html">..</a> <code class="code">end</code></pre>Uniform Resource Locators (URLs)
<p>

 <b>Contents</b>
<p>
<ul>
<li><a href="Neturl.html#interface"><i>Interface</i></a></li>
</ul>

 The tutorial has been moved to <a href="Neturl_tut.html"><code class="code">Neturl_tut</code></a>.<br>
<hr width="100%">
<br>
<a name="interface"></a>
<h1>Interface</h1>
<p>

 This module provides functions to parse URLs, to print URLs, to
 store URLs, to modify URLs, and to apply relative URLs.
<p>

 URLs are strings formed according to pattern (1) or (2):
<p>
<OL>
<li><code class="code">scheme://user;userparams:password@host:port/path;params?query#fragment</code></li>
<li><code class="code">scheme:other;params?query#fragment</code></li>
</OL>

 The word at the beginning of the URL identifies the URL scheme
 (such as "http" or "file"). Depending on the scheme, not all of the
 parts are allowed, or parts may be omitted. This module defines the
 type <code class="code">url_syntax</code> whose values describe which parts are allowed/required/
 not allowed for a concrete URL scheme (see below).
<p>

 Not all characters are allowed in a URL. Some characters are allowed,
 but have the special task to separate the various parts of the URL
 (reserved characters).
 However, it is possible to include even invalid or reserved characters
 as normal content by applying the <code class="code">%</code>-encoding on these characters:
 A <code class="code">'%'</code> indicates that an encoded character follows, and the character
 is denoted by a two-digit hexadecimal number (e.g. <code class="code">%2f</code> for <code class="code">'/'</code>).
 In the following descriptions, the term "encoded string" means a string
 containing such <code class="code">%</code>-encoded characters, and the "decoded string" means a
 string not containing such characters.
 See the module <a href="Netencoding.Url.html"><code class="code">Netencoding.Url</code></a> for functions encoding or decoding
 strings.
<p>

 The type <code class="code">url</code> describes values storing the components of a URL,
 and the <code class="code">url_syntax</code> for the URL. In general, the components are
 stored as encoded strings; however, not for all components the
 <code class="code">%</code>-encoding is applicable.
<p>

 For convenience, the functions creating, modifying, and accessing
 URLs can handle both encoded and decoded strings. In order to
 avoid errors, the functions pass strings even in their decoded form.
<p>

 Note that there is currently no function to compare URLs. The
 canoncical comparison ( <code class="code">=</code> ) is not applicable because the same URL
 may be written in different ways.
<p>

 Note that nothing is said about the character set/encoding of URLs.
 Some protocols and standards prefer UTF-8 as fundamental encoding
 and apply the <code class="code">%</code>-encoding on top of it; i.e. the byte sequence
 representing a character in UTF-8 is <code class="code">%</code>-encoded. 
<p>

 <b>Standards Compliance</b>
<p>

 This module implements RFC 1738 and RFC 1808. There is also a newer
 RFC, 2396, updating the former RFCs, but this module is not fully 
 compatible with RFC 2396. The following (minor) problems may occur:
<p>
<ul>
<li>The module escapes more characters than needed. All characters that
   are "unsafe" or "reserved" in either RFC document are escaped.</li>
<li>URL parameters (appended with a ";") are handled as in RFCs 1738/1808.
   In RFC 2396, every path component may have parameters, and the
   algorithm to resolve relative URLs is different in this point.
   If it is required to apply RFC 2396, one can disable URL parameters
   in the syntax, and extract them from the path by a self-written
   postprocessor. Usually, this is only required for <code class="code">imap</code> URLs.</li>
</ul>

 In one point, RFC 2396 is preferred:
<p>
<ul>
<li>Authorities may be terminated by a question mark, as in
   <code class="code">"http://host?query"</code>. This is illegal in RFC 1738. The consequence
   is, however, that question marks in user strings must be escaped.</li>
</ul>
<br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONMalformed_URL"></a>Malformed_URL</pre>
<div class="info">
Raised by a number of functions when encountering a badly formed
 URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALextract_url_scheme"></a>extract_url_scheme : <code class="type">string -> string</code></pre><div class="info">
Returns the URL scheme from the string representation of an URL. 
 E.g. <code class="code">extract_url_scheme "http://host/path" = "http"</code>. 
 The scheme name is always converted to lowercase characters.
 Raises <code class="code">Malformed_URL</code> if the scheme name is not found.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEurl_syntax_option"></a><code class="type"></code>url_syntax_option = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Url_part_not_recognized</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The part, even if there, is not even recognized</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Url_part_allowed</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The part can be present</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Url_part_required</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The part must be present</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<br><code><span class="keyword">type</span> <a name="TYPEurl_syntax"></a><code class="type"></code>url_syntax = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_scheme&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_user&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_user_param&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_password&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_host&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_port&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_path&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_param&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_query&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_fragment&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_other&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl_syntax_option">url_syntax_option</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_accepts_8bits&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_is_valid&nbsp;: <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>url_enable_relative&nbsp;: <code class="type">bool</code>;</code></td>

</tr></table>
}

<div class="info">
Values of type <code class="code">url_syntax</code> describe which components of an URL are
 recognized, which are allowed (and optional), and which are required.
 Not all combinations are valid; the predicate expressed by the
 function <code class="code">url_syntax_is_valid</code> must hold.
<p>

 The function <code class="code">url_is_valid</code> is applied when a fresh URL is created
 and must return <code class="code">true</code>. This function allows it to add an arbitrary
 validity criterion to <code class="code">url_syntax</code>. (Note that the URL passed to 
 this function is not fully working; you can safely assume that the
 accessor functions <code class="code">url_scheme</code> etc. can be applied to it.)
<p>

 Switch <code class="code">url_accepts_8bit</code>: If <code class="code">true</code>, the bytes with code 128 to
 255 are treated like alphanumeric characters; if <code class="code">false</code> these bytes
 are illegal (but it is still possible to include such byte in their
 encoded form: <code class="code">%80</code> to <code class="code">%FF</code>).
<p>

 Switch <code class="code">url_enable_relative</code>: If <code class="code">true</code>, the syntax allows relative
 URLs in principle. Actually, parsing of relative URLs is possible
 when the optional parts are flagged as <code class="code">Url_part_allowed</code> and not
 as <code class="code">Url_part_required</code>. However, it is useful to specify URL syntaxes
 always as absolute URLs, and to weaken them on demand when a relative
 URL is found by the parser. This switch enables that. In particular,
 the function <code class="code">partial_url_syntax</code> checks this flag.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEurl"></a><code class="type"></code>url </pre>
<div class="info">
Values of type <code class="code">url</code> describe concrete URLs. Every URL must have
 a fundamental <code class="code">url_syntax</code>, and it is only possible to create URLs
 conforming to the syntax. See <code class="code">make_url</code> for further information.<br>
</div>

<pre><span class="keyword">val</span> <a name="VALurl_syntax_is_valid"></a>url_syntax_is_valid : <code class="type"><a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -> bool</code></pre><div class="info">
Checks whether the passed <code class="code">url_syntax</code> is valid. This means:<ul>
<li>If passwords are recognized, users (and hosts) must be recognized, too</li>
<li>If ports are recognized, hosts must be recognized, too</li>
<li>If users are recognized, hosts must be recognized, too</li>
<li>Either the syntax recognizes one of the phrases
   { user, password, host, port, path }, or the syntax recognized
   the phrase 'other'.</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpartial_url_syntax"></a>partial_url_syntax : <code class="type"><a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -> <a href="Neturl.html#TYPEurl_syntax">url_syntax</a></code></pre><div class="info">
Transforms the syntax into another syntax where all required parts are
 changed into optional parts.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnull_url_syntax"></a>null_url_syntax : <code class="type"><a href="Neturl.html#TYPEurl_syntax">url_syntax</a></code></pre><div class="info">
An URL syntax that recognizes nothing. Use this as base for your own
 definitions, e.g.
 <pre><code class="code"> let my_syntax = { null_url_syntax with
                     url_enable_host = Url_part_required; ... }
 </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALip_url_syntax"></a>ip_url_syntax : <code class="type"><a href="Neturl.html#TYPEurl_syntax">url_syntax</a></code></pre><div class="info">
Syntax for IP based protocols. This syntax allows scheme, user,
 password, host, port, path, param, query, fragment, but not "other".
 It does not accept 8 bit bytes.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcommon_url_syntax"></a>common_url_syntax : <code class="type">(string, <a href="Neturl.html#TYPEurl_syntax">url_syntax</a>) Hashtbl.t</code></pre><div class="info">
Syntax descriptions for common URL schemes. The key of the hashtable
 is the scheme name, and the value is the corresponding syntax.
<p>
<ul>
<li><code class="code">"file"</code>: scheme, host?, path</li>
<li><code class="code">"ftp"</code>: scheme, user?, password?, host, port?, path?, param?
   Note: param is not checked.</li>
<li><code class="code">"http"</code>, <code class="code">"https"</code>: 
   scheme, user?, password?, host, port?, path?, query?</li>
<li><code class="code">"mailto"</code>: scheme, other, query? (RFC 2368)</li>
<li><code class="code">"pop"</code>, <code class="code">"pops"</code>: scheme, user?, user_param?, password?, host, port?
   Note: user_param is not checked.
   (RFC 2384)</li>
<li><code class="code">"imap"</code>, <code class="code">"imaps"</code>: scheme, user?, user_param?, password?, host, port?,
   path?, query? (RFC 2192)
   Note: "param" is intentionally not recognized to get the resolution of
   relative URLs as described in the RFC. When analysing this kind of URL,
   it is recommended to re-parse it with "param" enabled.</li>
<li><code class="code">"news"</code>: scheme, other (RFC 1738)</li>
<li><code class="code">"nntp"</code>, <code class="code">"nntps"</code>: scheme, host, port?, path (with two components) 
   (RFC 1738)</li>
<li><code class="code">"data"</code>: scheme, other (RFC 2397). "other" is not further decomposed.</li>
<li><code class="code">"ipp"</code>, <code class="code">"ipps"</code>: scheme, host, port? , path?, query? (RFC 3510)</li>
<li><code class="code">"cid"</code>, <code class="code">"mid"</code>: Content/message identifiers: scheme, other</li>
</ul>

 Notes:<ul>
<li>These syntax descriptions can be weakened for partial/relative URLs 
   by changing the required parts to optional parts: See the function
   <code class="code">partial_url_syntax</code>.</li>
<li>None of the descriptions allows fragments. These can be enabled by
   setting <code class="code">url_enable_fragment</code> to <code class="code">Url_part_allowed</code>. E.g.
   <pre><code class="code"> { file_url_syntax with url_enable_fragment = Url_part_allowed } </code></pre></li>
<li>8 bit bytes are not accepted</li>
<li>A large number of standardised scheme syntaxes are not available,
   e.g. gopher, prospero, wais. The selection is a bit subjective,
   but I have tried to omit protocols that are no longer in common
   use, or that are very special.</li>
<li>The LDAP URL syntax (RFC 1959) does not fit into our scheme, it
   is omitted for now because of this.</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnull_url"></a>null_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
A URL without any component and <code class="code">null_url_syntax</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake_url"></a>make_url : <code class="type">?encoded:bool -><br>       ?scheme:string -><br>       ?user:string -><br>       ?user_param:string list -><br>       ?password:string -><br>       ?host:string -><br>       ?port:int -><br>       ?path:string list -><br>       ?param:string list -><br>       ?query:string -><br>       ?fragment:string -> ?other:string -> <a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Creates a URL from components:
<p>
<ul>
<li>The components <code class="code">scheme</code> and <code class="code">host</code> are simple strings to which the
   <code class="code">%</code>-encoding is not applicable.</li>
<li>The component <code class="code">port</code> is a simple number. Of course, the <code class="code">%</code>-encoding
   is not applicable, too.</li>
<li>The components <code class="code">user</code>, <code class="code">password</code>, <code class="code">query</code>, <code class="code">fragment</code>, and <code class="code">other</code>
   are strings which may contain <code class="code">%</code>-encoded characters. By default,
   you can pass any string for these components, and problematic characters 
   are automatically encoded. If you set <code class="code">encoded:true</code>, the passed
   strings must already be encoded, but the function checks whether
   the encoding is syntactically correct.
   Note that for <code class="code">query</code> even the characters <code class="code">'?'</code> and <code class="code">'='</code> are encoded
   by default, so you need to set <code class="code">encoded:true</code> to pass a reasonable
   query string.</li>
<li>The components <code class="code">user_param</code>, <code class="code">path</code> and <code class="code">param</code> are lists of strings which may
   contain <code class="code">%</code>-encoded characters. Again, the default is to pass
   decoded strings to the function, and the function encodes them
   automatically, and by setting <code class="code">encoded:true</code> the caller is responsible
   for encoding the strings. Passing empty lists for these components
   means that they are not part of the constructed URL.
   See below for the respresentation of these components.</li>
</ul>

 The strings representing the components do not
 contain the characters separating the components from each other. 
<p>

 The created URL must conform to the <code class="code">url_syntax</code>, i.e.:<ul>
<li>The URL must only contain components which are recognized by the
   syntax</li>
<li>The URL must contain components which are required by the syntax</li>
<li>The URL must fulfill the predicate expressed by the <code class="code">url_is_valid</code>
   function of the syntax.</li>
</ul>

 The path of a URL is represented as a list of <code class="code">'/'</code>-separated path
 components. i.e.
<p>

 <code class="code"> [ s1; s2; ...; sN ] </code>  represents the path  
                        <code class="code">s1 ^ "/" ^ s2 ^ "/" ^ ... ^ "/" ^ sN</code>
<p>

 As special cases:<ul>
<li> <code class="code">[]</code>                   is the non-existing path</li>
<li> <code class="code">[ "" ]</code>               is <code class="code">"/"</code></li>
<li> <code class="code">[ "";"" ]</code>            is illegal</li>
</ul>

 Except of <code class="code">s1</code> and <code class="code">sN</code>, the path components must not be empty strings.
<p>

 To avoid ambiguities, it is illegal to create URLs with both relative
 paths (<code class="code">s1 &lt;&gt; ""</code>) and host components.
<p>

 Parameters of URLs (<code class="code">param</code> and <code class="code">user_param</code>) are components 
 beginning with <code class="code">';'</code>. The list
 of parameters is represented as list of strings where the strings
 contain the value following <code class="code">';'</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmodify_url"></a>modify_url : <code class="type">?syntax:<a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -><br>       ?encoded:bool -><br>       ?scheme:string -><br>       ?user:string -><br>       ?user_param:string list -><br>       ?password:string -><br>       ?host:string -><br>       ?port:int -><br>       ?path:string list -><br>       ?param:string list -><br>       ?query:string -><br>       ?fragment:string -> ?other:string -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Modifies the passed components and returns the modified URL. 
 The modfied URL shares unmodified components with the original
 URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_from_url"></a>remove_from_url : <code class="type">?scheme:bool -><br>       ?user:bool -><br>       ?user_param:bool -><br>       ?password:bool -><br>       ?host:bool -><br>       ?port:bool -><br>       ?path:bool -><br>       ?param:bool -><br>       ?query:bool -> ?fragment:bool -> ?other:bool -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Removes the <code class="code">true</code> components from the URL, and returns the modified
 URL.
 The modfied URL shares unmodified components with the original
 URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefault_url"></a>default_url : <code class="type">?encoded:bool -><br>       ?scheme:string -><br>       ?user:string -><br>       ?user_param:string list -><br>       ?password:string -><br>       ?host:string -><br>       ?port:int -><br>       ?path:string list -><br>       ?param:string list -><br>       ?query:string -><br>       ?fragment:string -> ?other:string -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Adds missing components and returns the modified URL.
 The modfied URL shares unmodified components with the original
 URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALundefault_url"></a>undefault_url : <code class="type">?scheme:string -><br>       ?user:string -><br>       ?user_param:string list -><br>       ?password:string -><br>       ?host:string -><br>       ?port:int -><br>       ?path:string list -><br>       ?param:string list -><br>       ?query:string -><br>       ?fragment:string -> ?other:string -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Removes components from the URL if they have the passed value, and
 returns the modified URL.
 Note: The values must always be passed in <b>encoded</b> form!
 The modfied URL shares unmodified components with the original
 URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALurl_syntax_of_url"></a>url_syntax_of_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl_syntax">url_syntax</a></code></pre><div class="info">
Returns the <code class="code">url_syntax</code> record of a URL.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALurl_of_string"></a>url_of_string : <code class="type"><a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -> string -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Parses the passed string according to the passed <code class="code">url_syntax</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_of_url"></a>string_of_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><div class="info">
Returns the URL as string<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparse_url"></a>parse_url : <code class="type">?schemes:(string, <a href="Neturl.html#TYPEurl_syntax">url_syntax</a>) Hashtbl.t -><br>       ?base_syntax:<a href="Neturl.html#TYPEurl_syntax">url_syntax</a> -><br>       ?accept_8bits:bool -> ?enable_fragment:bool -> string -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Parses the string and returns the URL the string represents.
 If the URL is absolute (i.e. begins with a scheme like
 "http:..."), the syntax will be looked up in <code class="code">schemes</code>.
 If the URL is relative, the <code class="code">base_syntax</code> will be taken
 if passed. Without <code class="code">base_syntax</code>, relative URLs cannot be
 parsed.
<p>

<br>
</div>
<div class="param_info"><code class="code">schemes</code> : This hashtable maps scheme names to syntax descriptions.
   The default is <code class="code">common_url_syntax</code>.</div>
<div class="param_info"><code class="code">base_syntax</code> : If passed, the function can parse relative URLs
   according to this syntax. If not passed, the function will raise
   <code class="code">Malformed_URL</code> on a relative URL.</div>
<div class="param_info"><code class="code">accept_8bits</code> : If <code class="code">false</code>, the default, it depends on the
   syntax descriptions in <code class="code">schemes</code> whether 8 bit characters are
   accepted in the input or not. If <code class="code">true</code>, 8 bit characters are
   always accepted.</div>
<div class="param_info"><code class="code">enable_fragment</code> : If <code class="code">false</code>, the default, it depends on the
   syntax descriptions in <code class="code">schemes</code> whether fragment identifiers
   (e.g. "#fragment") are recognized or not. If <code class="code">true</code>, fragments
   are always recognized.</div>
<pre><span class="keyword">val</span> <a name="VALfixup_url_string"></a>fixup_url_string : <code class="type">string -> string</code></pre><div class="info">
Escapes some unsafe or "unwise" characters that are commonly used
 in URL strings: space, &lt; &gt; { } [ ] ^ \\ | and double quotes.
 Call this function before parsing the URL to support these
 characters.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALurl_provides"></a>url_provides : <code class="type">?scheme:bool -><br>       ?user:bool -><br>       ?user_param:bool -><br>       ?password:bool -><br>       ?host:bool -><br>       ?port:bool -><br>       ?path:bool -><br>       ?param:bool -><br>       ?query:bool -> ?fragment:bool -> ?other:bool -> <a href="Neturl.html#TYPEurl">url</a> -> bool</code></pre><div class="info">
Returns <code class="code">true</code> iff the URL has all of the components passed with
 <code class="code">true</code> value.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALurl_scheme"></a>url_scheme : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_user"></a>url_user : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_user_param"></a>url_user_param : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALurl_password"></a>url_password : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_host"></a>url_host : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_port"></a>url_port : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALurl_path"></a>url_path : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALurl_param"></a>url_param : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALurl_query"></a>url_query : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_fragment"></a>url_fragment : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALurl_other"></a>url_other : <code class="type">?encoded:bool -> <a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><div class="info">
Return components of the URL. The functions return decoded strings
 unless <code class="code">encoded:true</code> is set.
 If the component does not exist, the exception <code class="code">Not_found</code>
 is raised.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_path"></a>split_path : <code class="type">string -> string list</code></pre><div class="info">
Splits a <code class="code">'/'</code>-separated path into components (e.g. to set up the
 <code class="code">path</code> argument of <code class="code">make_url</code>).
 E.g.
 <pre><code class="code"> split_path "a/b/c" = [ "a"; "b"; "c" ],
 split_path "/a/b"  = [ ""; "a"; "b" ],
 split_path "a/b/"  = [ "a"; "b"; "" ] </code></pre>
 Beware that <code class="code">split_path ".."</code> returns <code class="code">[".."]</code> while <code class="code">split_path "../"</code>
 returns <code class="code">[".."; ""]</code>.  The two will behave differently, for example
 when used with <a href="Neturl.html#VALapply_relative_url"><code class="code">Neturl.apply_relative_url</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALjoin_path"></a>join_path : <code class="type">string list -> string</code></pre><div class="info">
Concatenates the path components (reverse function of split_path).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnorm_path"></a>norm_path : <code class="type">string list -> string list</code></pre><div class="info">
Removes <code class="code">"."</code> and <code class="code">".."</code> from the path if possible. Deletes double slashes.
<p>

 <b>Examples</b>
<p>

 <ul>
<li><code class="code">norm_path ["."] = []</code>
<p>

           means: "." = ""</li>
<li><code class="code">norm_path ["."; ""] = []</code>
<p>

           means: "./" = ""</li>
<li><code class="code">norm_path ["a"; "."] = ["a"; ""]</code>
<p>

           means: "a/." = "a/"</li>
<li><code class="code">norm_path ["a"; "b"; "."] = ["a"; "b"; ""]</code>
<p>

           means: "a/b/." = "a/b/"</li>
<li><code class="code">norm_path ["a"; "."; "b"; "."] = ["a"; "b"; ""]</code>
<p>

           means: "a/./b/." = "a/b/"</li>
<li><code class="code">norm_path [".."] = [".."; ""]</code>
<p>

           means: ".." = "../"</li>
<li><code class="code">norm_path [".."; ""] = [".."; ""]</code>
<p>

           means: "../" = "../"</li>
<li><code class="code">norm_path ["a"; "b"; ".."; "c" ] = ["a"; "c"]</code>
<p>

           means: "a/b/../c" = "a/c"</li>
<li><code class="code">norm_path ["a"; "b"; ".."; "c"; ""] = ["a"; "c"; ""]</code>
<p>

           means: "a/b/../c/" = "a/c/"</li>
<li><code class="code">norm_path ["";"";"a";"";"b"] = [""; "a"; "b"]</code>
<p>

           means: "//a//b" = "/a/b"</li>
<li><code class="code">norm_path ["a"; "b"; ""; ".."; "c"; ""] = ["a"; "c"; ""]</code>
<p>

           means: "a/b//../c/" = "a/c/"</li>
<li><code class="code">norm_path ["a"; ".."] = []</code>
<p>

           means: "a/.." = ""</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALapply_relative_url"></a>apply_relative_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
<code class="code">apply_relative_url base rel</code>:
 Interprets <code class="code">rel</code> relative to <code class="code">base</code> and returns the new URL. This
 function implements RFC 1808.
<p>

 It is not necessary that <code class="code">rel</code> has the same syntax as <code class="code">base</code>.
 Note, however, that it is checked whether the resulting URL is
 syntactically correct with the syntax of <code class="code">base</code>. If not, the
 exception <code class="code">Malformed_URL</code> will be raised.
<p>

 Examples (the URLs are represented as strings, see <a href="Neturl.html#VALsplit_path"><code class="code">Neturl.split_path</code></a>
 to split them for <a href="Neturl.html#VALmake_url"><code class="code">Neturl.make_url</code></a>):
<p>

 base="x/y", url="a/b" =&gt; result="x/a/b"
 base="x/y/", url="a/b" =&gt; result="x/y/a/b"
 base="x/y/..", url="a/b" =&gt; result="x/y/a/b"   (beware!)
 base="x/y/../", url="a/b" =&gt; result="x/a/b"<br>
</div>
<pre><span class="keyword">val</span> <a name="VALensure_absolute_url"></a>ensure_absolute_url : <code class="type">?base:<a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a> -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
If the anonymous URL is absolute, it is just returned as result of 
 this function. If the URL is relative, it is tried to make it 
 absolute by resolving it relative to <code class="code">base</code>. If there is no <code class="code">base</code>,
 this will fail, and the function raises <code class="code">Malformed_URL</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_url_of_local_path"></a>file_url_of_local_path : <code class="type">?getcwd:(unit -> string) -> string -> <a href="Neturl.html#TYPEurl">url</a></code></pre><div class="info">
Generates a URL with "file" scheme from the passed path name. The
 URL is always absolute, i.e. the current directory is prepended if the
 path is not absolute.
<p>

 Note that no character set conversions are performed.
<p>

 Win32: The input path name may use forward or backward slashes. 
 Absolute paths with drive letters and UNC paths are recognised.
 Relative paths with drive letters, however, are not recognised
 (e.g. <code class="code">"c:file"</code>), as it is not possible to access the drive-specific
 working directory from the O'Caml runtime.
<p>

 Cygwin: The input path name may use forward or backward slashes. 
 Absolute paths with drive letters and UNC paths are recognised.
 The former are translated to <code class="code">"/cygdrive"</code> names.
<p>

<br>
</div>
<div class="param_info"><code class="code">getcwd</code> : The function returns the path taken as current working 
   directory. Note that for
   Win32 this must be either an absolute name with drive letter,
   or an UNC path. Default: <code class="code">Sys.getcwd</code></div>
<pre><span class="keyword">val</span> <a name="VALlocal_path_of_file_url"></a>local_path_of_file_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> string</code></pre><div class="info">
Extracts the path from an absolute file URL, and returns a 
 correct path name.
<p>

 If the URL is not a file URL, or is not absolute, the function will
 fail.
<p>

 Win32: The URL must either contain a drive letter, or must refer
 to another host.
<p>

 Cygwin: Drive letters and remote URLs are recognised.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_url"></a>print_url : <code class="type"><a href="Neturl.html#TYPEurl">url</a> -> unit</code></pre><div class="info">
Printer for the toploop.<br>
</div>
</body></html>