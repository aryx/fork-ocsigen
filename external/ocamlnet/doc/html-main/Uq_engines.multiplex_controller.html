<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Uq_engines.datagram_socket_provider.html">
<link rel="next" href="Uq_engines.datagram_multiplex_controller.html">
<link rel="Up" href="Uq_engines.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html"><title>Ocamlnet 3 Reference Manual : Uq_engines.multiplex_controller</title>
</head>
<body>
<div class="navbar"><a href="Uq_engines.datagram_socket_provider.html">Previous</a>
&nbsp;<a href="Uq_engines.html">Up</a>
&nbsp;<a href="Uq_engines.datagram_multiplex_controller.html">Next</a>
</div>
<center><h1>Class type <a href="type_Uq_engines.multiplex_controller.html">Uq_engines.multiplex_controller</a></h1></center>
<br>
<pre><span class="keyword">class type</span> <a name="TYPEmultiplex_controller"></a>multiplex_controller = <code class="code">object</code> <a href="Uq_engines.multiplex_controller.html">..</a> <code class="code">end</code></pre>A <code class="code">multiplex_controller</code> is a quite low-level device to abstract
 bidirectional socket connections. It is independent of any real
 device.
<p>

 There can be a reader, a writer (or both), or alternatively,
 the shutdown process may be in progress. One cannot have more than
 one reader and more than more writer.<br>
<hr width="100%">
<pre><span class="keyword">method</span> <a name="METHODalive"></a>alive : <code class="type">bool</code></pre><div class="info">
If the controller is alive, the socket is not yet completely down.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODmem_supported"></a>mem_supported : <code class="type">bool</code></pre><div class="info">
Whether <code class="code">start_mem_reading</code> and <code class="code">start_mem_writing</code> are possible<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODevent_system"></a>event_system : <code class="type"><a href="Unixqueue.event_system.html">Unixqueue.event_system</a></code></pre><div class="info">
Returns the event system<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreading"></a>reading : <code class="type">bool</code></pre><div class="info">
True iff there is a reader<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_reading"></a>start_reading : <code class="type">?peek:(unit -> unit) -><br>       when_done:(exn option -> int -> unit) -> string -> int -> int -> unit</code></pre><div class="info">
Start reading from the connection. When data is available, the
 <code class="code">when_done</code> callback is invoked. The int is the number of read
 bytes. It is 0 if an error occurred which is indicated by the
 exception. The exception <code class="code">End_of_file</code> is used when the end of the
 data stream is reached. The exception <code class="code">Cancelled</code> indicates that
 reading has been cancelled in the meantime.
<p>

 This starts one-time read job only, i.e. it is not restarted
 after <code class="code">when_done</code> has been invoked.
<p>

 It is an error to start reading several times.
<p>

 The function <code class="code">peek</code> is called immediately before data is read in
 from the underlying communication channel.
<p>

 For getting an engine-based version of <code class="code">start_reading</code>, use
 a <code class="code">signal_engine</code>:
 <pre><code class="code"> 
    let (e, signal) = signal_engine esys in
    mplex # start_reading ~when_done:(fun xo n -&gt; signal (xo,n)) ...
 </code></pre>
 Now <code class="code">e</code> will transition to <code class="code">`Done(x0,n)</code> when the read is done.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_mem_reading"></a>start_mem_reading : <code class="type">?peek:(unit -> unit) -><br>       when_done:(exn option -> int -> unit) -><br>       <a href="Netsys_mem.html#TYPEmemory">Netsys_mem.memory</a> -> int -> int -> unit</code></pre><div class="info">
Same as <code class="code">start_reading</code>, but puts the data into a <code class="code">memory</code> buffer.
        There is an optimization for the case that the descriptor is a
        connected socket, or supports <code class="code">Unix.read</code>. If this is not possible
        the method raises <code class="code">Mem_not_supported</code>.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcancel_reading"></a>cancel_reading : <code class="type">unit -> unit</code></pre><div class="info">
Cancels the read job. The <code class="code">when_done</code> callback is invoked with the
 number of bytes read so far (which may be 0) and the exception
 <code class="code">Cancelled</code>.
<p>

 It is no error if there is no reader.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODwriting"></a>writing : <code class="type">bool</code></pre><div class="info">
True iff there is a writer<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_writing"></a>start_writing : <code class="type">when_done:(exn option -> int -> unit) -> string -> int -> int -> unit</code></pre><div class="info">
Start writing to the connection. When data is written, the
 <code class="code">when_done</code> callback is invoked. The int is the number of written
 bytes. It is 0 if an error occurred which is indicated by the
 exception. The exception <code class="code">Cancelled</code> indicates that
 writing has been cancelled in the meantime.
<p>

 This starts one-time write job only, i.e. it is not restarted
 after <code class="code">when_done</code> has been invoked.
<p>

 It is an error to start writing several times.
<p>

 See the comment for <code class="code">start_reading</code> for how to get an engine-based
 version of this method.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_mem_writing"></a>start_mem_writing : <code class="type">when_done:(exn option -> int -> unit) -><br>       <a href="Netsys_mem.html#TYPEmemory">Netsys_mem.memory</a> -> int -> int -> unit</code></pre><div class="info">
Same as <code class="code">start_writing</code>, but takes the data from a <code class="code">memory</code> buffer.
        There is an optimization for the case that the descriptor is a
        connected socket, or supports <code class="code">Unix.write</code>. If this is not possible
        the method raises <code class="code">Mem_not_supported</code>.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODsupports_half_open_connection"></a>supports_half_open_connection : <code class="type">bool</code></pre><div class="info">
Whether the underlying transport mechanism can close the write side
 of the connection only (half-open connection).<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_writing_eof"></a>start_writing_eof : <code class="type">when_done:(exn option -> unit) -> unit -> unit</code></pre><div class="info">
Start writing the EOF marker to the connection. When it is written,
 the <code class="code">when_done</code> callback is invoked. The exception <code class="code">Cancelled</code> indicates
 that writing has been cancelled in the meantime.
<p>

 This starts one-time write job only, i.e. it is not restarted
 after <code class="code">when_done</code> has been invoked.
<p>

 It is an error to start writing several times. It is an error to
 write EOF when the socket does not support half-open connections.
<p>

 See the comment for <code class="code">start_reading</code> for how to get an engine-based
 version of this method.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcancel_writing"></a>cancel_writing : <code class="type">unit -> unit</code></pre><div class="info">
Cancels the write job. The <code class="code">when_done</code> callback is invoked with the
 number of bytes read so far (which may be 0) and the exception
 <code class="code">Canelled</code>.
<p>

 It is no error if there is no writer.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODread_eof"></a>read_eof : <code class="type">bool</code></pre><div class="info">
Whether the EOF marker has been read<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODwrote_eof"></a>wrote_eof : <code class="type">bool</code></pre><div class="info">
Whether the EOF marker has been written<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODshutting_down"></a>shutting_down : <code class="type">bool</code></pre><div class="info">
True iff the shutdown is in progress<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_shutting_down"></a>start_shutting_down : <code class="type">?linger:float -> when_done:(exn option -> unit) -> unit -> unit</code></pre><div class="info">
Start shutting down the connection. After going through the shutdown
 procedure, the <code class="code">when_done</code> callback is invoked. The exception
 indicates whether an error happened. <code class="code">Cancelled</code> means that the
 shutdown operation has been cancelled in the meantime.
<p>

 The underlying file descriptor (if any) is not closed. A shutdown
 is only a protocol handshake. After a shutdown, both <code class="code">read_eof</code>
 and <code class="code">wrote_eof</code> are true. Call <code class="code">inactivate</code> to close the descriptor.
<p>

 Optionally, one can <code class="code">linger</code> for a certain period of time.
 It is only lingered when the EOF was written before the EOF 
 is seen on input.
 Defaults to <code class="code">linger 60.0</code>. Set to 0 to turn off.
<p>

 See the comment for <code class="code">start_reading</code> for how to get an engine-based
 version of this method.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcancel_shutting_down"></a>cancel_shutting_down : <code class="type">unit -> unit</code></pre><div class="info">
Cancels the shutdown procedure. After that, the state of the 
 connection is undefined. The <code class="code">when_done</code> callback is invoked with
 the exception <code class="code">Cancelled</code>.
<p>

 It is no error if no shutdown is in progress.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODinactivate"></a>inactivate : <code class="type">unit -> unit</code></pre><div class="info">
Inactivates the connection immediately, and releases any resources
 the controller is responsible for (e.g. closes file descriptors). 
 Note that this is more than
 cancelling all pending operations and shutting the connection down.
 However, the details of this method are implementation-defined.
 Callbacks are not invoked.<br>
</div>
</body></html>