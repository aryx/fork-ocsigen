<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Nethttpd_kernel.modify_http_protocol_config.html">
<link rel="next" href="Nethttpd_kernel.lingering_close.html">
<link rel="Up" href="Nethttpd_kernel.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html"><title>Ocamlnet 3 Reference Manual : Nethttpd_kernel.http_protocol</title>
</head>
<body>
<div class="navbar"><a href="Nethttpd_kernel.modify_http_protocol_config.html">Previous</a>
&nbsp;<a href="Nethttpd_kernel.html">Up</a>
&nbsp;<a href="Nethttpd_kernel.lingering_close.html">Next</a>
</div>
<center><h1>Class <a href="type_Nethttpd_kernel.http_protocol.html">Nethttpd_kernel.http_protocol</a></h1></center>
<br>
<pre><span class="keyword">class</span> <a name="TYPEhttp_protocol"></a>http_protocol : <code class="type">#<a href="Nethttpd_kernel.http_protocol_config.html">http_protocol_config</a> -> Unix.file_descr -> </code><code class="code">object</code> <a href="Nethttpd_kernel.http_protocol.html">..</a> <code class="code">end</code></pre>The core event loop of the HTTP daemon<br>
<hr width="100%">
<a name="2_ExchangeofHTTPmessages"></a>
<h2>Exchange of HTTP messages</h2>
<p>

 In <code class="code">fd</code> one must pass the already connected socket. It must be in non-
 blocking mode.
<p>

 How to use this class: Basically, one invokes <code class="code">cycle</code> until the whole
 message exchange on <code class="code">fd</code> is processed. <code class="code">cycle</code> receives data from the
 socket and sends data to the socket. There are two internal queues:
<p>

 The receive queue stores parts of received requests as <code class="code">req_token</code>.
 One can take values from the front of this queue by calling <code class="code">receive</code>.
<p>

 The response queue stores <code class="code">http_response</code> objects. Each of the objects
 corresponds to a request that was received before. This queue is handled
 fully automatically, but one can watch its length to see whether all responses
 are actually transmitted over the wire.
<p>

 The basic algorithm to process messages is:
<p>

 <pre><code class="code"> let rec next_token () =
   if proto # recv_queue_len = 0 then (
     proto # cycle ();
     next_token()
   )
   else
     proto # receive()

 let cur_token = ref (next_token()) in
 while !cur_token &lt;&gt; `Eof do
   (* Process first token of next request: *)
   match !cur_token with
    | `Req_header(req_line, header, resp) -&gt;
         (* Depending on [req_line], read further tokens until [`Req_end] *)
         ...
         (* Switch to the first token of the next message: *)
         cur_token := next_token()
    | `Timeout -&gt; ...
    | `Bad_request_error(e,resp) -&gt; 
          (* Generate 400 error, send it to [resp] *)
          ...
          (* Switch to the first token of the next message: *)
          cur_token := next_token()
    | `Fatal_error e -&gt; failwith "Crash"
    | _ -&gt; assert false
 done;
 while proto # resp_queue_len &gt; 0 do
   proto # cycle ();
 done;
 proto # shutdown()
 </code></pre>
<p>

 See the file <code class="code">tests/easy_daemon.ml</code> for a complete implementation of this.
<p>

 As one can see, it is essential to watch the lengths of the queues in order
 to figure out what has happened during <code class="code">cycle</code>.
<p>

 When the body of the request is empty, <code class="code">`Req_body</code> tokens are omitted.
 Note that for requests like <code class="code">GET</code> that always have an empty body, it is
 still possible that an errorneous client sends a body, and that <code class="code">`Req_body</code>
 tokens arrive. One must accept and ignore these tokens.
<p>

 Error handling: For serious errors, the connection is immediately aborted.
 In this case, <code class="code">receive</code> returns a <code class="code">`Fatal_error</code> token. Note that the
 queued responses cannot be sent! An example of this is <code class="code">`Broken_pipe</code>.
<p>

 There is a large class of non-serious errors, esp. format errors
 in the header and body. It is typical of these errors that one cannot determine
 the end of the request properly. For this reason, the daemon stops reading
 further data from the request, but the response queue is still delivered.
 For these errors, <code class="code">receive</code> returns a <code class="code">`Bad_request_error</code> token.
 This token contains a <code class="code">http_response</code> object that must be filled with a
 400 error response.<pre><span class="keyword">method</span> <a name="METHODcycle"></a>cycle : <code class="type">?block:float -> unit -> unit</code></pre><div class="info">
Looks at the file descriptor. If there is data to read from the descriptor,
 and there is free space in the input buffer, additional data is read into
 the buffer. It is also tried to interpret the new data as <code class="code">req_token</code>s,
 and if possible, new <code class="code">req_token</code>s are appended to the receive queue.
<p>

 If the response queue has objects, and there is really data one can send,
 and if the socket allows one to send data, it is tried to send as much
 data as possible.
<p>

 The option <code class="code">block</code> (default: 0) can be set to wait until data
 can be exchanged with the socket. This avoids busy waiting. The number
 is the duration in seconds to wait until the connection times out
 (0 means not to wait at all, -1 means to wait infinitely). When a timeout
 happens, and there is nothing to send, and the last request was fully
 processed, <code class="code">receive</code> will simply return <code class="code">`Timeout</code> (i.e. when 
 <code class="code">waiting_for_next_message</code> is <code class="code">true</code>). Otherwise, the
 fatal error <code class="code">`Timeout</code> is generated.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreceive"></a>receive : <code class="type">unit -> <a href="Nethttpd_kernel.html#TYPEreq_token">req_token</a></code></pre><div class="info">
Returns the first <code class="code">req_token</code> from the receive queue. Raises
 <code class="code">Recv_queue_empty</code> when the queue is empty (= has no new data)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODpeek_recv"></a>peek_recv : <code class="type">unit -> <a href="Nethttpd_kernel.html#TYPEreq_token">req_token</a></code></pre><div class="info">
Peeks the first token, but leaves it in the queue.
 Raises <code class="code">Recv_queue_empty</code> when the queue is empty.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODrecv_queue_len"></a>recv_queue_len : <code class="type">int</code></pre><div class="info">
Returns the length of the receive queue (number of tokens)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODresp_queue_len"></a>resp_queue_len : <code class="type">int</code></pre><div class="info">
Returns the length of the internal response queue (number of <code class="code">http_response</code>
 objects that have not yet fully processed)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODpipeline_len"></a>pipeline_len : <code class="type">int</code></pre><div class="info">
Returns the number of unanswered requests = Number of received <code class="code">`Req_end</code> tokens
 minus number of responses in state <code class="code">`Processed</code>. Note that <code class="code">pipeline_len</code>
 can become <code class="code">-1</code> when bad requests are responded.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODrecv_queue_byte_size"></a>recv_queue_byte_size : <code class="type">int</code></pre><div class="info">
Returns the (estimated) size of the input queue in bytes<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODwaiting_for_next_message"></a>waiting_for_next_message : <code class="type">bool</code></pre><div class="info">
Whether the kernel is currently waiting for the beginning of a new
 arriving HTTP request. This is <code class="code">false</code> while the request is being
 received.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODinput_timeout_class"></a>input_timeout_class : <code class="type">[ `Next_message | `None | `Normal ]</code></pre><div class="info">
Suggests the calculation of a timeout value for input:<ul>
<li><code class="code">`Normal</code>: The normal timeout value applies</li>
<li><code class="code">`Next_message</code>: The timeout value applies while waiting for the next message</li>
<li><code class="code">`None</code>: The connection is output-driven, no input timeout value</li>
</ul>
<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODshutdown"></a>shutdown : <code class="type">unit -> unit</code></pre><div class="info">
Shuts the socket down. Note: the descriptor is not closed.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODtimeout"></a>timeout : <code class="type">unit -> unit</code></pre><div class="info">
Process a timeout condition as <code class="code">cycle</code> does<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODabort"></a>abort : <code class="type"><a href="Nethttpd_kernel.html#TYPEfatal_error">fatal_error</a> -> unit</code></pre><div class="info">
Stops the transmission of data. The receive queue is cleared and filled
 with the two tokens <code class="code">`Fatal_error</code> and <code class="code">`Eof</code>. 
 The response queue is cleared. The <code class="code">cycle</code>
 method will return immediately without doing anything.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODfd"></a>fd : <code class="type">Unix.file_descr</code></pre><div class="info">
Just returns the socket<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODdo_input"></a>do_input : <code class="type">bool</code></pre><div class="info">
Returns <code class="code">true</code> iff the protocol engine is interested in new data from the
 socket. Returns <code class="code">false</code> after EOF and after errors.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODdo_output"></a>do_output : <code class="type">bool</code></pre><div class="info">
Returns <code class="code">true</code> iff the protocol engine has data to output to the socket<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODneed_linger"></a>need_linger : <code class="type">bool</code></pre><div class="info">
Returns <code class="code">true</code> when a lingering close operation is needed to reliably shut
 down the socket. In many cases, this expensive operation is not necessary.
 See the class <code class="code">lingering_close</code> below.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODconfig"></a>config : <code class="type"><a href="Nethttpd_kernel.http_protocol_config.html">http_protocol_config</a></code></pre><div class="info">
Just returns the configuration<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODtest_coverage"></a>test_coverage : <code class="type">string list</code></pre><div class="info">
For testing: returns a list of tokens indicating into which cases the program
 ran.<br>
</div>
</body></html>